{
  "base_happiness": 35,
  "capture_rate": 3,
  "color": {
    "name": "blue",
    "url": "https://pokeapi.co/api/v2/pokemon-color/2/"
  },
  "egg_groups": [
    {
      "name": "no-eggs",
      "url": "https://pokeapi.co/api/v2/egg-group/15/"
    }
  ],
  "evolution_chain": {
    "url": "https://pokeapi.co/api/v2/evolution-chain/73/"
  },
  "evolves_from_species": null,

      
  "form_descriptions": [],
  "forms_switchable": false,
  "gender_rate": -1,
  

 
  "has_gender_differences": false,
  "hatch_counter": 80,
  "id": 144,
  "is_baby": false,
  "is_legendary": true,
  "is_mythical": false,
  "name": "articuno",
 
}


// --------------------------------------------------------------------------------------------------------------
// old way without type generics 
//   const response = await globalThis.fetch(`${apiUrl}/${name}`);
//   const pokemonData = await response.json();
//   console.log(pokemonData);

//   const Pokemon = {
//     name: pokemonData.name,
//     url: pokemonData.url,
//     id: pokemonData.id,
//     base_experience: pokemonData.base_experience,
//     height: pokemonData.height,
//     weight: pokemonData.weight,
//   };
//   return Pokemon;

// create callPokemonApi function -> PokemonType will be an interface that matches what is returned from the REST API
// export const pokemon_by_pk: NonNullable<
//   QueryResolvers["pokemon_by_pk"]
// > = async (_parent, _args, _ctx) => {
//   return callPokemonApi<PokemonType>(`${apiUrl}/${_args.id}`);
// };

// you can create func with a type helper mapped over the top, and manually pass the type to them
